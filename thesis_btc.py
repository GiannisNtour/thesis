# -*- coding: utf-8 -*-
"""thesis-btc.ipynb

Automatically generated by Colaboratory.

### Data

Data Link: https://www.cryptodatadownload.com/data/

### About our data

Dataset contains the bitcoin price info per minute.

The info we interested in, is the close column. 

Close is the price of BTC at this moment.
Volume is the ammount of BTC which bought or sold at this moment.
Open price is the price which open the data in this one minute, the low
price is the lowest price which reach at that moment and the high price is
the highest price which reach at that moment.

### Download Data
"""

"""## Import libraries"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from sklearn import preprocessing
from sklearn.metrics import mean_squared_error, mean_absolute_error, explained_variance_score, r2_score
from sklearn.preprocessing import MinMaxScaler
import random
import time
import copy
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense, Dropout, LSTM, BatchNormalization
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, TensorBoard
import tensorflow as tf
# %matplotlib inline

# size of dataframe
ROWS_OF_DATASET = 1440 * 10
#### LSTM ###
# size of test data 
TEST_DATA_LSTM = 1440 * 1
# size of input in lstm
LOOK_BACK_LSTM = 10
# size of lstm units
LSTM_UNITS = 32
# percentage of train data that will be our validation data
VALIDATION_DATA = 0.2
# how many days we want to forecast
FORECASTING_MINUTES = 360

### RRL ###
# we want train data end in the same spot with lstm data
TRAIN_DATA_RRL = ROWS_OF_DATASET - TEST_DATA_LSTM
LOOK_BACK_RRL = LOOK_BACK_LSTM
EPOCHS_RRL = 1000
LEARNING_RATE_RRL = 0.5

"""## Import data"""

btc_input_df  = pd.read_csv("BTC-USD.csv", parse_dates=["time"], nrows=ROWS_OF_DATASET)
btc_input_df.head()

btc_input_df = btc_input_df.set_index('time')
btc_input_df.head()

btc_input_df = btc_input_df.sort_index()
btc_input_df.head()

print(btc_input_df.shape)
print("------------------------")
print(btc_input_df.info())

btc_input_df.head()

btc_input_df.tail()

"""## Plot informations"""

plt.figure(figsize=(20,5))
plt.title("Bitcoin Price", fontsize=20)
btc_input_df.close.plot(figsize=(25,5))
plt.xlabel("Time", fontsize=15)
plt.ylabel("USD", fontsize=15)
plt.tight_layout()

plt.figure(figsize=(25,5))
plt.suptitle('Area Plots', fontsize=22)

plt.subplot(1,2,1)
btc_input_df.close.diff().plot.area(stacked=False,)
plt.ylabel("USD", fontsize="15")
plt.xlabel("Time", fontsize="15")
plt.title("Differences", fontsize="15")

plt.subplot(1,2,2)
btc_input_df.close.pct_change().plot.area(stacked=False,)
plt.ylabel("Percentage", fontsize="15")
plt.xlabel("Time", fontsize="15")
plt.title("Percentage Change", fontsize="15")

plt.tight_layout()
plt.show()

plt.figure(figsize=(25,12))

plt.subplot(3,3,1)
btc_input_df.close.hist(bins=150)
plt.xlabel("USD", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.title('Close', fontsize=15)

plt.subplot(3,3,2)
btc_input_df.close.pct_change().hist(bins=150)
plt.xlabel("Percentage", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.title('Percentage Change', fontsize=15)

plt.subplot(3,3,3)
btc_input_df.close.diff().hist(bins=150)
plt.xlabel("USD", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.title('Differences', fontsize=15)

plt.tight_layout()
plt.show()

# κάνουμε plot το corelation 
plt.figure(figsize=(20,12))

plt.subplot(3,3,1)
pd.plotting.lag_plot(btc_input_df['close'], lag=1) #minute lag
plt.xlabel("y(t)", fontsize=15)
plt.ylabel("y(t + 1)", fontsize=15)
plt.title('1-Minute Lag', fontsize=15)

plt.subplot(3,3,2)
pd.plotting.lag_plot(btc_input_df['close'], lag=5) 
plt.xlabel("y(t)", fontsize=15)
plt.ylabel("y(t + 5)", fontsize=15)
plt.title('5-Minute Lag', fontsize=15)

plt.subplot(3,3,3)
pd.plotting.lag_plot(btc_input_df['close'], lag=15) 
plt.xlabel("y(t)", fontsize=15)
plt.ylabel("y(t + 15)", fontsize=15)
plt.title('15-Minute Lag', fontsize=15)

plt.tight_layout()
plt.show()

"""## Pre processing data for LSTM model"""

btc_closing_price = btc_input_df['close'].copy()
btc_closing_price.head()

df_train= btc_closing_price[:-TEST_DATA_LSTM].copy()
df_test= btc_closing_price[-TEST_DATA_LSTM:].copy()

plt.figure(figsize=(20,5))
plt.plot(df_train, label='Train', linewidth=2, )
plt.plot(df_test, label='Test', linewidth=2)
plt.xlabel("Date", fontsize=15)
plt.ylabel('USD', fontsize=15)
plt.title('Train Data VS Test Data', fontsize=20)
plt.legend(loc='best', fontsize=15)
plt.tight_layout()
plt.show()

df_train= df_train.values.reshape(df_train.shape[0],1)
df_test= df_test.values.reshape(df_test.shape[0],1)

df_train.shape

scaler_train = MinMaxScaler(feature_range=(-1, 1))
scaled_train = scaler_train.fit_transform(df_train)

scaler_test = MinMaxScaler(feature_range=(-1, 1))
scaled_test = scaler_test.fit_transform(df_test)

def dataset_generator_lstm(dataset, look_back=10):
    dataX, dataY = [], []
    
    for i in range(len(dataset) - look_back):   
        window_size_x = dataset[i:(i + look_back)]
        dataX.append(window_size_x)
        dataY.append(dataset[i + look_back])
        
    return np.array(dataX), np.array(dataY)

trainX, trainY = dataset_generator_lstm(scaled_train, look_back= LOOK_BACK_LSTM)
testX, testY = dataset_generator_lstm(scaled_test, look_back= LOOK_BACK_LSTM)

print("trainX: ", trainX.shape)
print("trainY: ", trainY.shape)
print("testΧ: ", testX.shape)
print("testY", testY.shape)

trainX = np.reshape(trainX, (trainX.shape[0], trainX.shape[1], 1))
testX = np.reshape(testX, (testX.shape[0], testX.shape[1], 1 ))

print("Shape of trainX: ", trainX.shape)
print("Shape of testX: ", testX.shape)

"""## Create LSTM model"""

model = Sequential()

model.add(LSTM(units=LSTM_UNITS, activation ='tanh', return_sequences=False, input_shape = (trainX.shape[1], trainX.shape[2])))
model.add(Dropout(0.2))

# model.add(LSTM(units = 64, activation = 'tanh', return_sequences=True, input_shape = (trainX.shape[1], trainX.shape[2])))
# model.add(Dropout(0.2))

# model.add(LSTM(units = 32, activation = 'tanh', return_sequences=False, input_shape = (trainX.shape[1], trainX.shape[2])))
# model.add(Dropout(0.2))

# model.add(LSTM(units = 64, activation = 'tanh', return_sequences=True, input_shape = (trainX.shape[1], trainX.shape[2])))
# model.add(Dropout(0.2))

# model.add(LSTM(units = 64, activation = 'tanh',return_sequences=False,input_shape = (trainX.shape[1], trainX.shape[2])))
# model.add(Dropout(0.2))

model.add(Dense(units = 1))

model.summary()

model.compile(optimizer = 'adam', loss = 'mean_squared_error')
checkpoint_path = f'./models/btc_model_{int(time.time())}.hdf5'
checkpoint = ModelCheckpoint(filepath=checkpoint_path, 
                             monitor='val_loss',
                             verbose=1, 
                             save_best_only=True,
                             mode='min')

earlystopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
callbacks = [checkpoint, earlystopping]
history = model.fit(trainX, trainY, batch_size = 64, epochs = 100, 
                    verbose=1, shuffle=False, 
                    validation_split=VALIDATION_DATA, callbacks=callbacks)

model_from_saved_checkpoint = load_model(checkpoint_path)

"""## How good is our model?"""

plt.figure(figsize=(8,5))
plt.plot(history.history['loss'], label='loss')
plt.plot(history.history['val_loss'], label='val_loss')
plt.legend(loc='best', fontsize=15)
plt.xlabel("Epoch",fontsize=15)
plt.ylabel("Loss", fontsize=15)
plt.title("Model Performance", fontsize=20)
plt.show()

# Τα μετατρέπουμε στην κανονική τους μορφή και κάνουμε τις προβλέψεις
predicted_btc_price_test_data = model_from_saved_checkpoint.predict(testX)
predicted_btc_price_test_data = scaler_test.inverse_transform(predicted_btc_price_test_data.reshape(testX.shape[0], 1))
test_actual = scaler_test.inverse_transform(testY.reshape(testX.shape[0], 1))

def rmse(predictions, targets):
    return np.sqrt(np.mean((predictions-targets)**2))

print(f"Mean Absolute Error: {mean_absolute_error(predicted_btc_price_test_data, test_actual)}")
print(f"Mean Square Error: {mean_squared_error(predicted_btc_price_test_data, test_actual)}")
print(f"r2 score: {r2_score(predicted_btc_price_test_data, test_actual)}")
print(f"Root Mean Square Error: {rmse(predicted_btc_price_test_data, test_actual)}")

# Τα μετατρέπουμε στην κανονική τους μορφή και κάνουμε τις προβλέψεις
predicted_btc_price_train_data = model_from_saved_checkpoint.predict(trainX)
predicted_btc_price_train_data = scaler_train.inverse_transform(predicted_btc_price_train_data.reshape(trainX.shape[0], 1))
train_actual = scaler_train.inverse_transform(trainY.reshape(trainY.shape[0], 1))

plt.figure(figsize=(15,10))

plt.subplot(2,2,1)
plt.plot(predicted_btc_price_train_data, 'r', marker='.', label='Predicted Train')
plt.plot(train_actual, marker='.', label='Actual Train', alpha=0.3)
plt.xlabel("Tick", fontsize=15)
plt.ylabel("USD", fontsize=15)
plt.title("Price", fontsize=20)
plt.legend(loc='best', fontsize='15')

plt.subplot(2,2,2)
plt.plot(np.diff(train_actual, axis=0),label='Actual Train', alpha=0.5, linewidth=2)
plt.plot(np.diff(predicted_btc_price_train_data, axis=0), label='Predicted Train', linewidth=2)
plt.xlabel("Tick", fontsize=15)
plt.ylabel("USD", fontsize=15)
plt.title("Price Differences", fontsize=20)
plt.legend(loc='best', fontsize='15')
plt.tight_layout()

plt.subplot(2,2,3)
plt.plot(predicted_btc_price_test_data, 'r', marker='.', label='Predicted Test')
plt.plot(test_actual, marker='.', label='Actual Test', alpha=0.3)
plt.xlabel("Tick", fontsize=15)
plt.ylabel("USD", fontsize=15)
plt.title("Price", fontsize=20)
plt.legend(loc='best', fontsize='15')

plt.subplot(2,2,4)
plt.plot(np.diff(test_actual, axis=0),label='Actual Test', alpha=0.5, linewidth=2)
plt.plot(np.diff(predicted_btc_price_test_data, axis=0), label='Predicted Test', linewidth=2)
plt.xlabel("Tick", fontsize=15)
plt.ylabel("USD", fontsize=15)
plt.title("Price Differences", fontsize=20)
plt.legend(loc='best', fontsize='15')
plt.tight_layout()
plt.show()

"""## Forecasting"""

lookback_period = FORECASTING_MINUTES
testX_last_days = testX[testX.shape[0] - lookback_period:]
print(testX_last_days.shape)
predicted_days_forecast_price_test_x = []

for i in range(lookback_period):  
    predicted_forecast_price_test_x = model_from_saved_checkpoint.predict(testX_last_days[i:i+1])
    predicted_forecast_price_test_x = scaler_test.inverse_transform(predicted_forecast_price_test_x.reshape(-1, 1))
    predicted_days_forecast_price_test_x.append(predicted_forecast_price_test_x)

predicted_days_forecast_price_test_x = np.array(predicted_days_forecast_price_test_x)
predicted_days_forecast_price_test_x = predicted_days_forecast_price_test_x.flatten()

predicted_btc_price_test_data = predicted_btc_price_test_data.flatten()
predicted_btc_test_concatenated = np.concatenate((predicted_btc_price_test_data, predicted_days_forecast_price_test_x))

plt.figure(figsize=(20,10))

plt.subplot(2,2,1)
plt.plot(predicted_btc_test_concatenated, 'r', marker='.', label='Predicted Test')
plt.plot(test_actual, marker='.', label='Actual Test', alpha=0.3)
plt.xlabel("Tick", fontsize=15)
plt.ylabel("USD", fontsize=15)
plt.title("Price", fontsize=20)
plt.legend(loc='best', fontsize='15')

plt.subplot(2,2,2)
plt.plot(np.diff(test_actual, axis=0),label='Actual Test', alpha=0.5, linewidth=2)
plt.plot(np.diff(predicted_btc_test_concatenated, axis=0), label='Predicted Test', linewidth=2)
plt.xlabel("Tick", fontsize=15)
plt.ylabel("USD", fontsize=15)
plt.title("Price Differences", fontsize=20)
plt.legend(loc='best', fontsize='15')
plt.tight_layout()
plt.show()

"""## Create dataframe for our trade positions"""

df_strategy_actual = pd.DataFrame(test_actual)
df_strategy_predicted = pd.DataFrame(predicted_btc_price_test_data)

df_strategy_actual = df_strategy_actual.rename(columns={0: "close"})
df_strategy_predicted = df_strategy_predicted.rename(columns={0: "close"})

def classify(current, future):
    if future is None:
        return
    """
    Επιστρέφει 1 αν η τιμή στο μέλλον είναι αυξημένη ή
    -1 αν η τιμή στο μέλλον είναι μειωμένη
    """
    if float(future) > float(current):
        return 1
    elif float(future) < float(current):
        return -1

df_strategy_actual['future'] = df_strategy_actual["close"].shift(-1)
df_strategy_predicted['future'] = df_strategy_predicted["close"].shift(-1)
df_strategy_actual['target'] = list(map(classify, df_strategy_actual["close"], df_strategy_actual["future"]))
df_strategy_predicted['target'] = list(map(classify, df_strategy_predicted["close"], df_strategy_predicted["future"]))

frames = [df_strategy_actual, df_strategy_predicted]
result = pd.concat(frames, axis=1, ignore_index=True)
result = result.rename(columns={0: "actual_close", 
                                1:"actual_future_close", 
                                2:"actual_target",
                                3:"predicted_close",
                                4:"predicted_future_close",
                                5:"predicted_target"})
result.dropna(inplace = True)
result["prcnt_change"] = (result['predicted_future_close'] - result['predicted_close'] ) / result['predicted_close']
result.reset_index(inplace=True, drop=True)
result.head(10)

"""## RRL Stock Trading"""

def positions(x, w):
    M = len(w) - 2
    T = len(x)
    Ft = np.zeros(T)
    for t in range(M, T):
        xt = np.concatenate([[1], x[t - M:t], [Ft[t - 1]]])
        Ft[t] = np.tanh(np.dot(w, xt))
    return Ft

def returns(Ft, x, delta=0):
    T = len(x)
    rets = Ft[0:T - 1] * x[1:T] - delta * np.abs(Ft[1:T] - Ft[0:T - 1])
    return np.concatenate([[0], rets])

def gradient(x, w, delta):
    Ft = positions(x, w)
    R = returns(Ft, x, delta)
    T = len(x)
    M = len(w) - 2
    
    A = np.mean(R)
    B = np.mean(np.square(R))
    S = A / np.sqrt(B - A ** 2)

    dSdA = S * (1 + S ** 2) / A
    dSdB = -S ** 3 / 2 / A ** 2
    dAdR = 1. / T
    dBdR = 2. / T * R
    
    grad = np.zeros(M + 2)  
    dFpdw = np.zeros(M + 2)  
    
    for t in range(M, T):
        xt = np.concatenate([[1], x[t - M:t], [Ft[t-1]]])
        dRdF = -delta * np.sign(Ft[t] - Ft[t-1])
        dRdFp = x[t] + delta * np.sign(Ft[t] - Ft[t-1])
        dFdw = (1 - Ft[t] ** 2) * (xt + w[-1] * dFpdw)
        dSdw = (dSdA * dAdR + dSdB * dBdR[t]) * (dRdF * dFdw + dRdFp * dFpdw)
        grad = grad + dSdw
        dFpdw = dFdw
        
    return grad, S

def train(x, epochs=2000, M=8, commission=0, learning_rate = 0.3):
    w = np.random.rand(M + 2)
    sharpes = np.zeros(epochs) 
    for i in range(epochs):
        grad, sharpe = gradient(x, w, commission)
        w = w + grad * learning_rate
        sharpes[i] = sharpe
    
    print("finished training")
    return w, sharpes

rets = btc_input_df['close'].copy().diff()[1:ROWS_OF_DATASET]
x = np.array(rets)
N = TRAIN_DATA_RRL 
x_train = x[:N]
x_test = x[N:]

x_test

plt.figure(figsize=(15,5))
plt.plot(rets[:N], label='Train', linewidth=2,)
plt.plot(rets[N:], label='Test', linewidth=2,)
plt.ylabel('USD', fontsize=15)
plt.xlabel('Date', fontsize=15)
plt.title('Train Data VS Test Data', fontsize=16)
plt.legend(loc='best', fontsize=16)
plt.tight_layout()
plt.show()

# # standardizing the values
std = np.std(x_train)
mean = np.mean(x_train)
x_tr = x_train[:]

x_train = (x_train - mean) / std
# x_test = (x_test - mean) / std

# # for lstm predictions
x_lstm_test = np.diff(predicted_btc_price_test_data)
# x_lstm_test = (x_lstm_test - mean) / std

# Commented out IPython magic to ensure Python compatibility.
# %%time
np.random.seed(0)
print('start training')
w, sharpes = train(x_train, epochs=EPOCHS_RRL, M=LOOK_BACK_RRL, commission=0, learning_rate=LEARNING_RATE_RRL)

plt.figure(figsize=(10,5))
plt.title("Model Performance", fontsize=20)
plt.plot(sharpes)
plt.xlabel('Epoch Number', fontsize=15)
plt.ylabel('Sharpe Ratio', fontsize=15)
plt.tight_layout()
print(f"Sharpe ratio: {sharpes[-1]}")
plt.show()

x_train = x_tr[:]
train_returns = returns(positions(x_train, w), x_train)
test_returns = returns(positions(x_test, w), x_test)

train_positions = positions(x_train, w)
test_positions = positions(x_test, w)

lstm_returns= returns(positions(x_lstm_test, w), x_test[:len(x_lstm_test)-1])
lstm_positions = positions(x_lstm_test, w)

plt.figure(figsize=(20,10))

plt.subplot(4,2,1)
plt.xlabel("Tick")
plt.ylabel("Ft")
plt.plot(train_positions)
plt.title("Train Ft (decisions)")

plt.subplot(4,2,2)
plt.xlabel("Tick")
plt.ylabel('USD')
plt.plot(train_returns)
plt.title("Train Returns")

plt.subplot(4,2,3)
plt.xlabel("Tick")
plt.ylabel("Ft")
plt.plot(test_positions)
plt.title("Test Ft (decisions)")

plt.subplot(4,2,4)
plt.xlabel("Tick")
plt.ylabel('USD')
plt.plot(test_returns)
plt.title("Test Returns")

plt.subplot(4,2,5)
plt.xlabel("Tick")
plt.ylabel('Ft')
plt.plot(lstm_positions)
plt.title("LSTM predictions Ft (decisions)")

plt.subplot(4,2,6)
plt.xlabel("Tick")
plt.ylabel('USD')
plt.plot(lstm_returns)
plt.title("LSTM predictions Returns")

plt.subplot(4,2,7)
plt.xlabel("Tick")
plt.ylabel('USD')
plt.plot(train_returns.cumsum(), label="RRL")

plt.subplot(4,2,7)
plt.xlabel("Tick")
plt.ylabel('USD')
plt.plot(x_train.cumsum(), color="green", label="Buy and Hold")
plt.title("Train Cumulative Returns VS Buy and Hold")
plt.legend()

plt.subplot(4,2,8)
plt.xlabel("Tick")
plt.ylabel('USD')
plt.plot(test_returns.cumsum(), label= "RRL")

plt.subplot(4,2,8)
plt.xlabel("Tick")
plt.plot(lstm_returns.cumsum(), label= "RRL ON LSTM")

plt.subplot(4,2,8)
plt.xlabel("Tick")
plt.plot(x_test.cumsum(), label= "Buy and Hold")
plt.title("Test Cumulative Returns VS LSTM Cumulative Returns VS Buy and Hold")
plt.legend(loc='best')

plt.tight_layout()
plt.show()

print(f"RL model on train data: {train_returns.cumsum()[-1]} USD" )
print(f"Buy and Hold - train Data: {x_train.cumsum()[-1]} USD")
print(f"RL model on test data: {test_returns.cumsum()[-1]} USD")
print(f"RL model on lstm predictions: {lstm_returns.cumsum()[-1]} USD")
print(f"Buy and Hold - test data: {x_test.cumsum()[-1]} USD")

plt.figure(figsize=(15,12))
HIST_BINS = 50

plt.subplot(3,2,1)
plt.ylabel("Frequency", )
plt.xlabel("Ft")
plt.hist(train_positions, bins=HIST_BINS)
plt.title("Train Ft (decisions)")

plt.subplot(3,2,2)
plt.ylabel("Frequency", )
plt.xlabel("USD")
plt.hist(train_returns, bins=HIST_BINS, label="RRL")
plt.hist(x_train.cumsum(), bins=HIST_BINS, alpha=0.3, label="Buy and Hold")
plt.title("Train Returns")
plt.legend()

plt.subplot(3,2,3)
plt.xlabel("Ft")
plt.ylabel("Frequency", )
plt.hist(test_positions, bins=HIST_BINS)
plt.title("Test Ft (decisions)")

plt.subplot(3,2,4)
plt.xlabel("USD")
plt.ylabel("Frequency",)
plt.hist(test_returns, bins=HIST_BINS, label="RRL")
plt.hist(x_test.cumsum(), bins=HIST_BINS, alpha=0.3, label="Buy and Hold")
plt.title("Test Returns")
plt.legend()

plt.subplot(3,2,5)
plt.xlabel("Ft")
plt.ylabel("Frequency",)
plt.hist(lstm_positions, bins=HIST_BINS)
plt.title("LSTM Ft (decisions)")

plt.subplot(3,2,6)
plt.ylabel("Frequency", )
plt.xlabel("USD")
plt.hist(lstm_returns, bins=HIST_BINS, label="RRL on LSTM predictions")
plt.hist(x_test.cumsum(), bins=HIST_BINS, alpha=0.3, label="Buy and Hold")
plt.title("LSTM Returns")
plt.legend()

plt.tight_layout()
plt.show()

"""## Functions for Trading"""

def trade_long(positions, stock_prices, usd=5000, btc=0, fee=0):
    """
    Αγοράζουμε για όσο προβλέπουμε πως θα ανέβει η τιμή και τα πουλάμε όλα 
    όταν προβλέπουμε πως θα πέσει η τιμή
    """
    cnt = 0
    total = []
    total.append(usd + btc * stock_prices[0])
    print(f"Start with: {total[0]} USD")
    for index in range(len(stock_prices) - 1): 

        # αγοράζουμε
        if positions[index] > 0 and usd > 0:
            buy = positions[index] * usd
            btc = buy / stock_prices[index] + btc
            usd = usd - buy - (fee * buy)
            cnt += 1
            total.append(usd + btc * stock_prices.iloc[index])
            continue

        # πουλάμε 
        if positions[index] < 0 and btc > 0: 
            usd = btc * stock_prices[index] + usd - (fee * btc)
            btc = 0
            cnt += 1
            total.append(usd + btc * stock_prices.iloc[index])
            continue
    
    print(f"End with: {total[-1]} USD\nProfit: {total[-1] - total[0]} USD\n# of trades: {cnt}\n")
    return total

def trade_short(positions, stock_prices, usd=0, btc=2, fee=0):
    """
    Στην συγκεκριμένη στρατηγική πουλάμε όλα τα bitcoin που έχουμε,
    και αγοράζουμε την ίδια ποσότητα που πουλήσαμε όταν προβλέπουμε πως θα ξαναανέβει η τιμή
    """
    cnt = 0
    total = []
    total.append(usd + btc * stock_prices[0])
    short = False
    first_btc = copy.deepcopy(btc)
    print(f"Start with: {total[0]} USD")
    for index in range(len(stock_prices) - 1): 
        # αγοράζουμε
        if positions[index] > 0  and usd > 0 and usd >= (first_btc) * stock_prices[index]:
            buy = copy.deepcopy(first_btc)
            btc = buy / stock_prices[index] + btc
            usd = usd - buy - (fee * buy)
            cnt += 1
            total.append(usd + btc * stock_prices.iloc[index])
            short = False
            continue

        # πουλάμε 
        if positions[index] < 0 and btc > first_btc - (first_btc / 2):  
            first_btc = copy.deepcopy(btc)
            usd = btc * stock_prices[index] + usd - (fee * btc)
            btc = 0
            cnt += 1
            total.append(usd + btc * stock_prices.iloc[index])
            short = True
            continue
        
    print(f"End with: {total[-1]} USD\nProfit: {total[-1] - total[0]} USD\n# of trades: {cnt}\n")
    
    return total

result['prcnt_change'].agg(['min', 'max', 'mean'])

print("---RRL LONG---")
total_rrl_long = trade_long(positions(x_test[:], w), result['actual_close'].copy())
print("---RRL ON LSTM LONG---")
total_rrl_lstm_long = trade_long(positions(x_lstm_test, w), result['actual_close'].copy())
print("---LSTM LONG---")
total_lstm_long = trade_long(result['prcnt_change'] * 100, result['actual_close'].copy())
print("---------------------------------------------------")
print("---RRL SHORT---")
total_rrl_short = trade_short(positions(x_test[:], w), result['actual_close'].copy())
print("---RRL ON LSTM SHORT---")
total_rrl_lstm_short = trade_short(positions(x_lstm_test, w), result['actual_close'].copy())
print("---LSTM SHORT---")
total_lstm_short = trade_short(result['prcnt_change'], result['actual_close'].copy())

plt.figure(figsize=(24,10))
plt.subplot(2,2,1)
plt.plot(total_rrl_long, label="RRL", linewidth=2)
plt.plot(total_rrl_lstm_long, label="RRL on LSTM predictions", linewidth=2)
plt.plot(total_lstm_long, label="LSTM", linewidth=2)
plt.xlabel('Trade')
plt.ylabel('USD')
plt.legend(loc='best')
plt.title("PORTFOLIO - LONG", fontsize=20)

plt.subplot(2,2,2)
plt.plot(total_rrl_short, label="RRL", linewidth=2)
plt.plot(total_rrl_lstm_short, label="RRL on LSTM predictions", linewidth=2)
plt.plot(total_lstm_short, label="LSTM", linewidth=2)
plt.xlabel('Trade')
plt.ylabel('USD')
plt.legend()
plt.title("PORTFOLIO - SHORT", fontsize=20)
plt.show()
